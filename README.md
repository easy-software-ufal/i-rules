## i-rules

### Improving Transformation Rules to Avoid Useless Mutants

## Abstract

Mutation testing is a program-transformation technique that injects code changes to a program and checks whether these changes are caught by the existing test suite. 
Despite attracting a lot of interest because of its reputation as a powerful adequacy criterion for test suites, the costs of using mutation testing are usually high, hindering its use in industry.
Useless mutants (eg., equivalents and duplicated) contribute to increasing costs of the mutation testing. 
An equivalent mutant is a mutant that has the same behavior as the original program. 
This way, this mutant is useless.
A duplicated mutant is a mutant that has the same behavior as another one.
Thus, one of them is useless.
Previous research has focused mainly on detecting useless mutants only after they are generated and compiled. 
The few solutions that try to prevent the mutant from being generated either do not provide practical effectiveness in their outcome, are specialized to domain-specific mutants, depend on expensive resources, or work with second-order mutants.
In previous work, we proposed improving the transformation rules embedded in the mutation operators in order to avoid useless mutants.
This work extends our previous findings in several ways.
We present \textit{i-rule}, a notation to avoid useless mutants.
We define an \textit{i-rule} as a triple ($term$, $transformations$, $constraints$) and differentiate \textit{i-rules} to avoid equivalents (E-RULE) and to avoid duplicated mutants (D-RULE).
We also present a strategy to help mutation tool developers find out occurrence patterns that lead to new \textit{i-rules}.
% To use the strategy, we need a set of programs as input, a set of mutants generated for each program by a mutation testing tool, and an automatic solution to detect or to suggest equivalent and duplicated mutants.
In our previous conference paper, we instantiated the strategy with programs automatically generated by the \jdolly{} program generator, which lead us to discover \NumberOfIdentifiedRulesFirstRound \textit{i-rules} for three common mutation testing tools for \java{} (\mujava{}, \major{}, and \pit{}).
In this article, we instantiate the strategy with manually-written \java{} programs, which lead us to find out \NumberOfIdentifiedRulesSecondRound new \textit{i-rules} for the same mutation tools.
To evaluate the effectiveness of the \textit{i-rules} on reducing costs, we implement \NumberOfImplementedRules of them in the \mujava{} tool and execute with classes of well-known projects such as \textit{ant}, \textit{bcel}, and \textit{commons-lang}.
The results show we reduced the number of mutants by almost 20\% on average and saved time to generate the mutants, thus demonstrating the potential of our approach for reducing mutation costs.
We also identified that one E-RULE was responsible for 90\% of all equivalent mutants avoided and six D-RULEs were responsible for approximately 86\% of the duplicated mutants avoided.

While we cannot guarantee to generate only useful mutants, we can demonstrate a considerable reduction in the number of useless mutant generations, leading to substantial temporal savings.
Our results are promising because (i) we \textit{avoid} useless mutants generation; 
(ii) our strategy can help with identifying more rules in case we execute against a different set of Java programs; 
(iii) our \mujava{} version, embedded with the rules, takes less time to create and compile the mutants than the original version;
and (iv) we implement only a subset of the rules we derived. 

```markdown
Syntax highlighted code block

# Header 1
## Header 2
### Header 3

- Bulleted
- List

1. Numbered
2. List

**Bold** and _Italic_ and `Code` text

[Link](url) and ![Image](src)
```

For more details see [GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/).

### Authors

Leo Fernandes - leonardo.oliveira@ifal.edu.br
Informatics Center, Federal University of Pernambuco---Recife, PE, Brazil
Informatics Coordination, Federal Institute of Alagoas---Maceió, AL, Brazil

Márcio Ribeiro - marcio@ic.ufal.br
Computing Institute, Federal University of Alagoas---Maceió, AL, Brazil

Pedro Pinheiro - pmop@ic.ufal.br
Computing Institute, Federal University of Alagoas---Maceió, AL, Brazil

Fabiano C. Ferrari - fcferrari@ufscar.br
Computing Department, Federal University of S\~ao Carlos---S\~ao Carlos, SP, Brazil

Rohit Gheyi - rohit@dsc.ufcg.edu.br
Computing Departament, Federal University of Campina Grande---Campina Grande, PB, Brazil

André Santos - alms@cin.ufpe.br
Informatics Center, Federal University of Pernambuco---Recife, PE, Brazil











### Support or Contact

Having trouble with Pages? Check out our [documentation](https://help.github.com/categories/github-pages-basics/) or [contact support](https://github.com/contact) and we’ll help you sort it out.
